<!DOCTYPE html> <html><head>
		<title>Explicit Register Renaming</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Vault - Explicit Register Renaming">
		<meta property="og:title" content="Explicit Register Renaming">
		<meta property="og:description" content="Vault - Explicit Register Renaming">
		<meta property="og:type" content="website">
		<meta property="og:url" content="universitÃ /aca/notes/explicit-register-renaming.html">
		<meta property="og:image" content="undefined">
		<meta property="og:site_name" content="Vault">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-c.mjx-c1D444.TEX-I::before{padding:.704em .791em .194em 0;content:"Q"}mjx-c.mjx-c1D457.TEX-I::before{padding:.661em .412em .204em 0;content:"j"}mjx-c.mjx-c50::before{padding:.683em .681em 0 0;content:"P"}mjx-c.mjx-c43::before{padding:.705em .722em .021em 0;content:"C"}mjx-c.mjx-c49::before{padding:.683em .361em 0 0;content:"I"}mjx-c.mjx-c44::before{padding:.683em .764em 0 0;content:"D"}mjx-c.mjx-c7A::before{padding:.431em .444em 0 0;content:"z"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c1D45C.TEX-I::before{padding:.441em .485em .011em 0;content:"o"}mjx-c.mjx-c1D462.TEX-I::before{padding:.442em .572em .011em 0;content:"u"}mjx-c.mjx-c1D452.TEX-I::before{padding:.442em .466em .011em 0;content:"e"}mjx-c.mjx-c1D45F.TEX-I::before{padding:.442em .451em .011em 0;content:"r"}mjx-c.mjx-c2265::before{padding:.636em .778em .138em 0;content:"â¥"}mjx-c.mjx-cD7::before{padding:.491em .778em 0 0;content:"Ã"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-c.mjx-c53::before{padding:.705em .556em .022em 0;content:"S"}mjx-c.mjx-c64::before{padding:.694em .556em .011em 0;content:"d"}mjx-c.mjx-c75::before{padding:.442em .556em .011em 0;content:"u"}mjx-c.mjx-c76::before{padding:.431em .528em .011em 0;content:"v"}mjx-c.mjx-c45::before{padding:.68em .681em 0 0;content:"E"}mjx-c.mjx-c78::before{padding:.431em .528em 0 0;content:"x"}mjx-c.mjx-c77::before{padding:.431em .722em .011em 0;content:"w"}mjx-c.mjx-c46::before{padding:.68em .653em 0 0;content:"F"}mjx-msub{display:inline-block;text-align:left}mjx-msup{display:inline-block;text-align:left}mjx-munderover{display:inline-block;text-align:left}mjx-munderover:not([limits=false]){padding-top:.1em}mjx-munderover:not([limits=false])>*{display:block}mjx-msubsup{display:inline-block;text-align:left}mjx-script{display:inline-block;padding-right:.05em;padding-left:.033em}mjx-script>mjx-spacer{display:block}mjx-texatom{display:inline-block;text-align:left}mjx-mtext{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-c.mjx-c1D44A.TEX-I::before{padding:.683em 1.048em .022em 0;content:"W"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c1D467.TEX-I::before{padding:.442em .465em .011em 0;content:"z"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c1D437.TEX-I::before{padding:.683em .828em 0 0;content:"D"}mjx-c.mjx-c1D44F.TEX-I::before{padding:.694em .429em .011em 0;content:"b"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c2211.TEX-S1::before{padding:.75em 1.056em .25em 0;content:"â"}mjx-c.mjx-c69::before{padding:.669em .278em 0 0;content:"i"}mjx-c.mjx-c6E::before{padding:.442em .556em 0 0;content:"n"}mjx-c.mjx-c66::before{padding:.705em .372em 0 0;content:"f"}mjx-c.mjx-c1D461.TEX-I::before{padding:.626em .361em .011em 0;content:"t"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c73::before{padding:.448em .394em .011em 0;content:"s"}mjx-c.mjx-c6D::before{padding:.442em .833em 0 0;content:"m"}mjx-c.mjx-c74::before{padding:.615em .389em .01em 0;content:"t"}mjx-c.mjx-c68::before{padding:.694em .556em 0 0;content:"h"}mjx-c.mjx-c20::before{padding:0 .25em 0 0;content:" "}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}mjx-c.mjx-c6F::before{padding:.448em .5em .01em 0;content:"o"}mjx-c.mjx-c65::before{padding:.448em .444em .011em 0;content:"e"}mjx-c.mjx-c72::before{padding:.442em .392em 0 0;content:"r"}mjx-c.mjx-c70::before{padding:.442em .556em .194em 0;content:"p"}mjx-c.mjx-c62::before{padding:.694em .556em .011em 0;content:"b"}mjx-c.mjx-c6C::before{padding:.694em .278em 0 0;content:"l"}mjx-c.mjx-c63::before{padding:.448em .444em .011em 0;content:"c"}mjx-c.mjx-c61::before{padding:.448em .5em .011em 0;content:"a"}mjx-c.mjx-c1D714.TEX-I::before{padding:.443em .622em .011em 0;content:"Ï"}mjx-c.mjx-c2217::before{padding:.465em .5em 0 0;content:"â"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c1D458.TEX-I::before{padding:.694em .521em .011em 0;content:"k"}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c1D460.TEX-I::before{padding:.442em .469em .01em 0;content:"s"}mjx-c.mjx-c1D45A.TEX-I::before{padding:.442em .878em .011em 0;content:"m"}mjx-c.mjx-c210E.TEX-I::before{padding:.694em .576em .011em 0;content:"h"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c1D449.TEX-I::before{padding:.683em .769em .022em 0;content:"V"}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;font-size-adjust:none;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"â"}mjx-c.mjx-c1D446.TEX-I::before{padding:.705em .645em .022em 0;content:"S"}</style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Explicit Register Renaming">Explicit Register Renaming</h1><div class="el-p"><p dir="auto"><a href="?query=tag:generated" class="tag" target="_blank" rel="noopener nofollow">#generated</a></p></div><div class="el-p"><p dir="auto"><a data-tooltip-position="top" aria-label="10.ACA25-registerrenaming.pdf" data-href="10.ACA25-registerrenaming.pdf" href="universitÃ /aca/10.aca25-registerrenaming.pdf" class="internal-link" target="_self" rel="noopener nofollow">source</a></p></div><div class="el-h2 heading-wrapper"><h2 data-heading="Introduction" dir="auto" class="heading" id="Introduction"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Introduction</h2><div class="heading-children"><div class="el-p"><p dir="auto">Register renaming is a fundamental hardware technique used in modern processors to increase instruction-level parallelism (ILP). Modern processor architectures face a significant challenge: the limited number of registers specified by the Instruction Set Architecture (ISA) creates artificial dependencies between instructions that don't actually need to depend on each other. Register renaming elegantly solves this problem by mapping a larger set of physical registers to the smaller set of architectural registers visible to the programmer.</p></div><div class="el-p"><p dir="auto">This document provides a thorough explanation of register renaming, its implementation methods, benefits, and how it integrates with other processor components. By understanding register renaming, you'll gain insight into how modern processors achieve their remarkable performance despite the constraints imposed by legacy instruction sets.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="The Problem: Register Dependencies and Hazards" dir="auto" class="heading" id="The_Problem:_Register_Dependencies_and_Hazards"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Problem: Register Dependencies and Hazards</h2><div class="heading-children"><div class="el-p"><p dir="auto">To understand why register renaming is necessary, we must first understand the problem it solves. In a processor, instructions operate on a limited number of registers defined by the Instruction Set Architecture. For example, the MIPS architecture specifies 32 general-purpose registers (R0-R31). This limited register count creates three types of <a data-tooltip-position="top" aria-label="Instruction-Level Parallelism > Dependences" data-href="Instruction-Level Parallelism#Dependences" href="universitÃ /aca/notes/instruction-level-parallelism.html#Dependences" class="internal-link" target="_self" rel="noopener nofollow">dependences</a> that can become hazard and cause pipeline to stall:</p></div><div class="el-p"><p dir="auto"><strong>RAW (Read After Write)</strong> is a true data dependency where an instruction needs to read a value that a previous instruction is writing. </p></div><div class="el-p"><p dir="auto"><strong>WAR (Write After Read)</strong> is a false dependency where an instruction needs to write to a register that a previous instruction is reading. </p></div><div class="el-p"><p dir="auto"><strong>WAW (Write After Write)</strong> is another false dependency where two instructions write to the same register.<br>
Only RAW represents a true data dependency that cannot be eliminated. WAR and WAW are artifacts of register reuse and can be eliminated with register renaming.</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="Example of False Dependencies" dir="auto" class="heading" id="Example_of_False_Dependencies"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Example of False Dependencies</h3><div class="heading-children"><div class="el-p"><p dir="auto">Consider this sequence of instructions:</p></div><div class="el-pre"><pre><code data-line="0">1. ADD R1, R2, R3   # R1 = R2 + R3
2. SUB R4, R1, R5   # R4 = R1 - R5
3. MUL R1, R6, R7   # R1 = R6 * R7
4. DIV R8, R1, R9   # R8 = R1 / R9
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">In this example, instruction 2 (SUB) must wait for instruction 1 (ADD) to complete because it needs the value of R1 that the ADD produces. This is a true RAW dependency that cannot be eliminated.</p></div><div class="el-p"><p dir="auto">However, instruction 3 (MUL) must wait for instruction 2 (SUB) to complete before writing to R1, even though there's no actual data dependency between them. This is a WAW hazard between instructions 1 and 3, because both write to R1.</p></div><div class="el-p"><p dir="auto">Additionally, instruction 4 (DIV) depends on instruction 3's result in R1, not instruction 1's, creating a true RAW dependency. In an ideal world, instructions 2 and 3 could execute in parallel as soon as their inputs are ready, but the reuse of register R1 creates an artificial dependency.</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="The Solution: Register Renaming" dir="auto" class="heading" id="The_Solution:_Register_Renaming"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Solution: Register Renaming</h2><div class="heading-children"><div class="el-p"><p dir="auto">Register renaming solves these false dependencies by providing more physical registers than the architecture specifies and mapping architectural registers to physical registers dynamically during execution. This approach effectively implements on-the-fly  something similar to a type of compiler transformation called "Static Single Assignment" (SSA) form, where each variable is assigned exactly once, but in hardware.</p></div><div class="el-p"><p dir="auto">The fundamental principle of register renaming is: <strong>Allocate a new physical register for every instruction that writes a result</strong>. This approach eliminates false dependencies in several ways:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">
<p>It eliminates WAR hazards by ensuring that reads always access the correct version of a register. When an instruction reads from a register, it uses the physical register currently mapped to that architectural register, regardless of future writes to the same architectural register.</p>
</li>
<li data-line="2" dir="auto">
<p>It eliminates WAW hazards by ensuring that each write goes to a different physical location. When multiple instructions write to the same architectural register, each is assigned a different physical register, so they can proceed independently.</p>
</li>
<li data-line="4" dir="auto">
<p>It preserves RAW dependencies by tracking which physical register holds the needed value. When an instruction reads from a register, it uses the physical register that contains the most recent value for that architectural register.</p>
</li>
</ul></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Types of Register Renaming" dir="auto" class="heading" id="Types_of_Register_Renaming"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Types of Register Renaming</h2><div class="heading-children"><div class="el-p"><p dir="auto">There are two primary approaches to register renaming in modern processors, each with its own advantages and implementation challenges.</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="Implicit Register Renaming ([[Tomasulo|Tomasulo's Algorithm]])" dir="auto" class="heading" id="Implicit_Register_Renaming_([[Tomasulo|Tomasulo's_Algorithm]])"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Implicit Register Renaming (<a data-tooltip-position="top" aria-label="Tomasulo" data-href="Tomasulo" href="universitÃ /aca/notes/tomasulo.html" class="internal-link" target="_self" rel="noopener nofollow">Tomasulo's Algorithm</a>)</h3><div class="heading-children"><div class="el-p"><p dir="auto">Implicit register renaming was pioneered by Robert Tomasulo at IBM in the 1960s. In this approach, user registers are implicitly renamed to reservation station tags. Each reservation station gets a unique tag, and results are tagged with their reservation station identifier and broadcast on a common data bus. Instructions waiting for that result capture it based on the tag.</p></div><div class="el-p"><p dir="auto">The key characteristic of Tomasulo's algorithm is that renaming is integrated with the scheduling mechanism. The reservation stations serve both to hold instructions waiting for their operands and to implement the renaming scheme. This tight coupling made sense in early implementations but has some limitations in scaling to modern processors.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Explicit Register Renaming" dir="auto" class="heading" id="Explicit_Register_Renaming"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Explicit Register Renaming</h3><div class="heading-children"><div class="el-p"><p dir="auto">Explicit register renaming uses a dedicated physical register file that is larger than the ISA register set. It maintains an explicit translation table (map table) tracking which physical register corresponds to each architectural register. This approach decouples renaming from scheduling, allowing more flexibility in pipeline design.</p></div><div class="el-p"><p dir="auto">Explicit renaming is more common in modern processors due to its scalability and flexibility. The remainder of this document focuses primarily on explicit register renaming, as it represents the state of the art in contemporary processor design.</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Explicit Register Renaming: Detailed Mechanism" dir="auto" class="heading" id="Explicit_Register_Renaming:_Detailed_Mechanism"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Explicit Register Renaming: Detailed Mechanism</h2><div class="heading-children"><div class="el-p"><p dir="auto">To implement explicit register renaming, processors need several hardware components working together to track register mappings and manage the pool of available registers.</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="Hardware Components" dir="auto" class="heading" id="Hardware_Components"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Hardware Components</h3><div class="heading-children"><div class="el-p"><embed src="10.ACA25-registerrenaming.pdf#page=12" style="width: 100%; max-width: 100%; height: 800px;"></div><div class="el-p"><p dir="auto">The <strong>Physical Register File (PRF)</strong> contains significantly more registers than the ISA specifies. For example, while the ISA might have 32 registers (R0-R31), the PRF might have 80+ physical registers (P0-P79+). This file holds both committed values (those that represent the current architectural state) and speculative values (those that are part of instructions still in flight).</p></div><div class="el-p"><p dir="auto">The <strong>Register Map Table (or "translation table/rename table/renaming map/current map table</strong> tracks the current mapping of each architectural register to its corresponding physical register. This table is updated during the instruction rename phase (decode/rename stage) as instructions are processed. </p></div><div class="el-p"><p dir="auto">The <strong>Free Register List (Freelist)</strong> contains physical registers that are available for allocation. </p></div><div class="el-p"><p dir="auto">The <strong>Retirement/Commit Register Map</strong> is a separate map table that holds only non-speculative, committed register mappings. This table is used for recovery after branch mispredictions or exceptions, allowing the processor to quickly restore the correct architectural state.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="The Pipeline Process with Register Renaming" dir="auto" class="heading" id="The_Pipeline_Process_with_Register_Renaming"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Pipeline Process with Register Renaming</h3><div class="heading-children"><div class="el-p"><p dir="auto">Register renaming fits into the processor pipeline in a specific way, interacting with other stages to enable out-of-order execution while maintaining correctness.</p></div><div class="el-p"><embed src="10.ACA25-registerrenaming.pdf#page=8" style="width: 100%; max-width: 100%; height: 800px;"></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">
<p>In the <strong>Fetch Stage</strong>, instructions are fetched from memory into the instruction queue, just as in a standard pipeline. No renaming occurs at this stage.</p>
</li>
<li data-line="2" dir="auto">
<p>The <strong>Decode and Rename Stage</strong> is where the magic happens. Instructions are decoded to identify source and destination registers. For each instruction that writes to a register, the processor allocates a new physical register from the freelist and updates the map table to point the destination architectural register to this new physical register. It also records the previous physical register mapping for potential recovery. For source registers, the processor looks up the current mapping in the map table to find which physical registers hold the needed values.</p>
</li>
<li data-line="4" dir="auto">
<p>During the <strong>Issue Stage</strong>, instructions are issued when all needed functional units are available (avoiding structural hazards), all source operands are available or will be available via forwarding, and there are enough physical registers available. If any of these conditions is not met, the instruction stalls at issue.</p>
</li>
<li data-line="6" dir="auto">
<p>In the <strong>Execute Stage</strong>, instructions execute in functional units. RAW hazards are handled by waiting for source operands or through forwarding, just as in a standard pipeline.</p>
</li>
<li data-line="8" dir="auto">
<p>The <strong>Write Result Stage</strong> is where results are written to the previously allocated physical registers. Thanks to register renaming, there's no need to check for WAR or WAW hazards as they've been eliminated by the renaming process.</p>
</li>
<li data-line="10" dir="auto">
<p>Finally, in the <strong>Commit Stage</strong>, instructions commit in program order. The mapping between architectural and physical registers is confirmed as non-speculative, and old physical registers that are no longer needed are returned to the freelist.</p>
</li>
</ol></div><div class="el-p"><embed src="Exe9_ACA25_Unsolved_issues.pdf#Page=26" style="width: 100%; max-width: 100%; height: 800px;"></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Register Deallocation: Managing the Physical Register Pool" dir="auto" class="heading" id="Register_Deallocation:_Managing_the_Physical_Register_Pool"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Register Deallocation: Managing the Physical Register Pool</h2><div class="heading-children"><div class="el-p"><p dir="auto">A critical aspect of register renaming is knowing when physical registers can be freed and returned to the freelist. Without proper management, the processor would eventually run out of physical registers and stall.</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="When can a physical register be freed?" dir="auto" class="heading" id="When_can_a_physical_register_be_freed?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>When can a physical register be freed?</h3><div class="heading-children"><div class="el-p"><p dir="auto">A physical register can be freed when both of these conditions are met:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">It no longer corresponds to any architectural register (has been overwritten by a newer instruction)</li>
<li data-line="1" dir="auto">No outstanding instructions need to read its value</li>
</ol></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Implementation Approaches" dir="auto" class="heading" id="Implementation_Approaches"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Implementation Approaches</h3><div class="heading-children"><div class="el-p"><p dir="auto">There are different ways to implement register deallocation, each with its own trade-offs.</p></div><div class="el-p"><p dir="auto">The simplest approach is to free a physical register when an instruction that overwrites the same architectural register commits. In our example, when the MUL instruction commits, P40 can be freed because R1 is now mapped to P42. This approach is slightly wasteful but easy to implement.</p></div><div class="el-p"><p dir="auto">A more optimized approach is to track when the last use of a physical register occurs and free the register after its last reader has executed. This requires additional bookkeeping but uses registers more efficiently.</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Integration with ROB" dir="auto" class="heading" id="Integration_with_ROB"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Integration with ROB</h2><div class="heading-children"><div class="el-p"><p dir="auto">Reorder Buffer is a data structure that stores instructions informations and it is used to preserves the correct order of instructions, ensuring in-order commitment of instructions.</p></div><div class="el-p"><p dir="auto">Many processors combine register renaming with a Reorder Buffer. Together they enable out-of-order execution with precise exception handling.</p></div><div class="el-p"><p dir="auto">ROB in Register Renaming set tracks:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">the original program order of instructions </li>
<li data-line="1" dir="auto">the status of each instruction (executing, completed, ready to commit)</li>
<li data-line="2" dir="auto">old register mappings for rollback.<br>
When an instruction is ready to commit, the ROB ensures it's the oldest instruction in the buffer, then updates the architectural state and frees resources.</li>
</ul></div><div class="el-p"><p dir="auto">Here some cases in which ROB has a fundamental role:</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="Register Renaming and Precise Exceptions" dir="auto" class="heading" id="Register_Renaming_and_Precise_Exceptions"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Register Renaming and Precise Exceptions</h3><div class="heading-children"><div class="el-p"><p dir="auto">Register renaming simplifies handling <a data-tooltip-position="top" aria-label="Exceptions in Computer Architecture > Precise Exceptions" data-href="Exceptions in Computer Architecture#Precise Exceptions" href="universitÃ /aca/notes/exceptions-in-computer-architecture.html#Precise_Exceptions" class="internal-link" target="_self" rel="noopener nofollow">precise exception</a> because it simplifies the rollback of the speculative state. In fact, speculative changes are not written directly in visible architectural register but on temporary physical registers. This means that in case of exceptions (but also in case of erroneous speculation as described in the next paragraph) the corrections is simply done by rolling back the Map Table.</p></div><div class="el-p"><p dir="auto">However, to ensure the correct handling of precise exceptions, it is crucial to have in-order commit (otherwise we could have <a data-href="Exceptions in Computer Architecture#Imprecise Exceptions" href="universitÃ /aca/notes/exceptions-in-computer-architecture.html#Imprecise_Exceptions" class="internal-link" target="_self" rel="noopener nofollow">Exceptions in Computer Architecture &gt; Imprecise Exceptions</a>). For this reason something like a ROB is needed.<br>
In particular, when an exception occurs,it is only handled when the instruction that generated it reaches the top of the ROB. In this way we ensure that all the previous instructions, that were not affected by the exception have committed (ensuring exception to be precise).<br>
Now the processor consults the ROB to identify all speculative instructions. It then discards these instructions, restores the map table to the state before the excepting instruction, returns physical registers to the freelist as needed, and resumes execution from the excepting instruction.</p></div><div class="el-p"><p dir="auto">This approach ensures that from the programmer's perspective, it appears as if the program executed sequentially up to the excepting instruction, which is critical for correct program behavior.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Register Renaming and Branch Prediction (erroneous speculation)" dir="auto" class="heading" id="Register_Renaming_and_Branch_Prediction_(erroneous_speculation)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Register Renaming and Branch Prediction (erroneous speculation)</h3><div class="heading-children"><div class="el-p"><p dir="auto">For speculative execution with branch prediction, register renaming plays a crucial role. When a branch is predicted, the processor continues renaming along the predicted path. If the prediction is correct, execution continues normally.</p></div><div class="el-p"><p dir="auto">If the branch is mispredicted, the processor must:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">flush all instructions after the branch from the pipeline </li>
<li data-line="1" dir="auto">flushing ROB entries corresponding to instruction that should have not been executed </li>
<li data-line="2" dir="auto">restore the Map Table to a valid checkpoint, that reflects a correct state before erroneous speculation </li>
<li data-line="3" dir="auto">free physical registers allocated after the branch</li>
<li data-line="4" dir="auto">begin fetching from the correct path.</li>
</ul></div><div class="el-p"><p dir="auto">This recovery mechanism allows the processor to speculate aggressively without compromising correctness.</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Benefits of Explicit Register Renaming" dir="auto" class="heading" id="Benefits_of_Explicit_Register_Renaming"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Benefits of Explicit Register Renaming</h2><div class="heading-children"><div class="el-p"><p dir="auto">Explicit register renaming offers several significant advantages that make it worth the additional hardware complexity.</p></div><div class="el-p"><p dir="auto">First, it eliminates WAR and WAW hazards by ensuring that each write operation uses a different physical register. This enables more instruction-level parallelism, allowing instructions to execute as soon as their true dependencies are resolved, without waiting for artificial dependencies.</p></div><div class="el-p"><p dir="auto">Second, it enables out-of-order execution by removing register conflicts as a constraint. Instructions can complete in any order once their dependencies are satisfied, which is crucial for hiding memory latency and maximizing functional unit utilization.</p></div><div class="el-p"><p dir="auto">Third, it decouples renaming from scheduling, allowing the pipeline to use various scheduling mechanisms. Whether using a standard pipeline, a Tomasulo-like approach, or a scoreboard, the renaming mechanism remains the same.</p></div><div class="el-p"><p dir="auto">Fourth, it simplifies data access by concentrating all register values in a unified physical register file. This allows standard forwarding or bypassing techniques to work well, without needing special cases for results that haven't yet been written back.</p></div><div class="el-p"><p dir="auto">Finally, it facilitates speculative execution by allowing multiple instances of the same architectural register to exist simultaneously. Recovery is simple: just restore the map table, without needing to move data between registers.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Challenges and Considerations" dir="auto" class="heading" id="Challenges_and_Considerations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Challenges and Considerations</h2><div class="heading-children"><div class="el-p"><p dir="auto">Despite its benefits, register renaming introduces some challenges that processor designers must address.</p></div><div class="el-p"><p dir="auto">Register allocation and deallocation require efficient mechanisms to track register usage. Stalls occur if free registers are exhausted, so the management of the freelist is critical for performance. Complex logic is needed to determine when registers can be freed, especially in the presence of exceptions and speculative execution.</p></div><div class="el-p"><p dir="auto">Map table management is another challenge. The processor needs multiple copies for speculative execution, fast lookup for high performance, and recovery mechanisms for exceptions and branch mispredictions. These requirements increase the complexity of the control logic.</p></div><div class="el-p"><p dir="auto">The increased hardware complexity also has implications for power consumption and chip area. Larger register files require more power and area, complex renaming logic adds to the control overhead, and additional structures for tracking register status consume resources.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Multiple Issue and Register Renaming" dir="auto" class="heading" id="Multiple_Issue_and_Register_Renaming"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Multiple Issue and Register Renaming</h2><div class="heading-children"><div class="el-p"><p dir="auto">Modern processors don't just rely on out-of-order execution to improve performance; they also implement multiple issue capabilities, where several instructions are processed simultaneously at various pipeline stages. Register renaming plays a crucial role in enabling efficient multiple issue execution.</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="The Challenge of Multiple Issue" dir="auto" class="heading" id="The_Challenge_of_Multiple_Issue"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Challenge of Multiple Issue</h3><div class="heading-children"><div class="el-p"><p dir="auto">Moving beyond a CPI (Cycles Per Instruction) of 1 requires processors to issue multiple instructions per cycle. This creates significant complexity in the issue logic, which must handle issuing every possible combination of dependent instructions in the same clock cycle.</p></div><div class="el-p"><p dir="auto">The fundamental bottleneck in dynamically scheduled superscalar processors is this issue logic. Since the number of possible dependency combinations increases with the square of the number of instructions that can be issued in one cycle, implementing issue logic becomes increasingly difficult for more than 4 instructions.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Basic Strategy for Multiple Issue with Register Renaming" dir="auto" class="heading" id="Basic_Strategy_for_Multiple_Issue_with_Register_Renaming"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Basic Strategy for Multiple Issue with Register Renaming</h3><div class="heading-children"><div class="el-p"><p dir="auto">When combining multiple issue with register renaming, processors use a sophisticated approach:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">The issue logic pre-reserves enough physical registers for the entire issue bundle (the group of instructions to be issued simultaneously).</li>
<li data-line="1" dir="auto">The processor assigns a reservation station and a reorder buffer entry for every instruction in the next issue bundle. If resources aren't available, only a subset of instructions is considered in sequential order.</li>
<li data-line="2" dir="auto">The processor analyzes all dependencies among the instructions in the bundle.</li>
<li data-line="3" dir="auto">When dependencies exist within the bundle (an instruction depends on an earlier instruction in the same bundle), the processor uses the pre-reserved physical register information to update the dependent instruction's information.</li>
<li data-line="4" dir="auto">For dependencies outside the bundle, the register renaming table provides the correct physical register number that holds (or will hold) the required value.</li>
</ol></div><div class="el-p"><p dir="auto">All of this complex dependency analysis and register allocation happens in parallel during a single clock cycle, demonstrating the remarkable sophistication of modern processor design.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Superscalar Register Renaming Implementation" dir="auto" class="heading" id="Superscalar_Register_Renaming_Implementation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Superscalar Register Renaming Implementation</h3><div class="heading-children"><div class="el-p"><p dir="auto">In a superscalar processor that can issue two or more instructions simultaneously:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">During decode, each instruction is allocated a new physical destination register.</li>
<li data-line="1" dir="auto">Source operands are renamed to point to the physical registers containing their most recent values.</li>
<li data-line="2" dir="auto">The execution units only see physical register numbers, completely insulated from the architectural register mappings.</li>
<li data-line="3" dir="auto">The processor must check for RAW (Read After Write) hazards between instructions issuing in the same cycle, which can be done in parallel with the rename table lookup.</li>
</ol></div><div class="el-p"><p dir="auto">The MIPS R10000, for example, could rename up to four serially RAW-dependent instructions per cycle, meaning it could process four instructions with a dependency chain in a single cycle. This was a remarkable achievement that significantly contributed to its high performance.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Multiple Commit" dir="auto" class="heading" id="Multiple_Commit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Multiple Commit</h3><div class="heading-children"><div class="el-p"><p dir="auto">Just as issuing multiple instructions creates complexity, so does committing multiple results. The processor needs to be able to commit multiple instructions in a single clock cycle to maintain throughput. This requires additional logic to update the architectural state and free physical registers for multiple instructions simultaneously.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Energy Considerations" dir="auto" class="heading" id="Energy_Considerations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Energy Considerations</h3><div class="heading-children"><div class="el-p"><p dir="auto">While speculation and multiple issue with register renaming increase performance, they also affect power consumption. Speculation raises power consumption but typically lowers execution time by more than it increases average power consumption. This means the total energy consumed may be less, depending on the number of instructions incorrectly executed.</p></div><div class="el-p"><p dir="auto">Experimental results have shown that in scientific code, misspeculation is on average small, while it can be significant (around 30% on average) in integer code. This highlights the continuing challenge of balancing performance with energy efficiency in modern processor design.</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Comparison: Implicit vs. Explicit Register Renaming" dir="auto" class="heading" id="Comparison:_Implicit_vs._Explicit_Register_Renaming"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Comparison: Implicit vs. Explicit Register Renaming</h2><div class="heading-children"><div class="el-p"><p dir="auto">While both implicit and explicit register renaming achieve the same goal of eliminating false dependencies, they differ in several important ways.</p></div><div class="el-p"><p dir="auto">Implicit renaming (Tomasulo's algorithm) renames registers to reservation station tags, while explicit renaming uses physical registers. This difference affects how results are communicated: implicit renaming relies on a broadcast mechanism, while explicit renaming uses a centralized register file.</p></div><div class="el-p"><p dir="auto">Integration with scheduling is another difference. Implicit renaming is tightly integrated with the scheduling mechanism, while explicit renaming decouples these functions, allowing more flexibility in pipeline design.</p></div><div class="el-p"><p dir="auto">Data storage also differs: implicit renaming distributes data across reservation stations, while explicit renaming centralizes it in the register file. This affects data access patterns and forwarding mechanisms.</p></div><div class="el-p"><p dir="auto">Implementation complexity varies as well. Implicit renaming requires a complex broadcast mechanism to communicate results, while explicit renaming needs complex renaming logic to manage the map table and freelist.</p></div><div class="el-p"><p dir="auto">In terms of scalability, implicit renaming is limited by the common data bus, which can become a bottleneck as the number of reservation stations increases. Explicit renaming scales better with register file size, allowing for larger instruction windows.</p></div><div class="el-p"><p dir="auto">Modern usage reflects these trade-offs, with explicit renaming being more widely used in contemporary processors due to its scalability and flexibility.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Summary and Key Takeaways" dir="auto" class="heading" id="Summary_and_Key_Takeaways"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Summary and Key Takeaways</h2><div class="heading-children"><div class="el-p"><p dir="auto">Register renaming is a powerful technique that helps modern processors achieve high levels of instruction-level parallelism despite the constraints imposed by legacy instruction sets. By providing more physical registers than architectural registers, it eliminates false dependencies and enables out-of-order execution.</p></div><div class="el-p"><p dir="auto">The key principle of register renaming is allocating a new physical register for every instruction that writes a result. This simple but powerful approach effectively implements on-the-fly what compiler writers call "Static Single Assignment" form.</p></div><div class="el-p"><p dir="auto">Explicit register renaming maintains a map table between architectural and physical registers, with free registers managed through a freelist. This approach decouples renaming from scheduling, allowing more flexibility in pipeline design.</p></div><div class="el-p"><p dir="auto">The process involves five key steps: decode and rename registers, track dependencies, execute instructions when dependencies are resolved, write results to physical registers, and commit and update the architectural state.</p></div><div class="el-p"><p dir="auto">Register renaming works together with reorder buffers to enable out-of-order execution with in-order commit, providing both performance and correctness.</p></div><div class="el-p"><p dir="auto">The technique simplifies recovery from mispredicted branches and exceptions by restoring previous mapping states, allowing aggressive speculation without compromising program semantics.</p></div><div class="el-p"><p dir="auto">Modern processors typically implement explicit register renaming with 20-80 additional physical registers, with the exact number depending on the expected instruction window size and performance goals.</p></div><div class="el-p"><p dir="auto">In conclusion, register renaming represents a significant advancement in computer architecture, enabling the high levels of instruction-level parallelism found in today's high-performance processors. By eliminating artificial dependencies, it allows processors to achieve performance levels that would otherwise be impossible with the limited register sets defined by instruction set architectures.</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Explicit Register Renaming"><div class="tree-item-contents heading-link" heading-name="Explicit Register Renaming"><span class="tree-item-title">Explicit Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Introduction"><div class="tree-item-contents heading-link" heading-name="Introduction"><span class="tree-item-title">Introduction</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#The_Problem:_Register_Dependencies_and_Hazards"><div class="tree-item-contents heading-link" heading-name="The Problem: Register Dependencies and Hazards"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">The Problem: Register Dependencies and Hazards</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Example_of_False_Dependencies"><div class="tree-item-contents heading-link" heading-name="Example of False Dependencies"><span class="tree-item-title">Example of False Dependencies</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#The_Solution:_Register_Renaming"><div class="tree-item-contents heading-link" heading-name="The Solution: Register Renaming"><span class="tree-item-title">The Solution: Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Types_of_Register_Renaming"><div class="tree-item-contents heading-link" heading-name="Types of Register Renaming"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Types of Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Implicit_Register_Renaming_([[Tomasulo|Tomasulo's_Algorithm]])"><div class="tree-item-contents heading-link" heading-name="Implicit Register Renaming ([[Tomasulo|Tomasulo's Algorithm]])"><span class="tree-item-title">Implicit Register Renaming (<a data-tooltip-position="top" aria-label="Tomasulo" data-href="Tomasulo" href="Tomasulo" class="internal-link" target="_blank" rel="noopener nofollow">Tomasulo's Algorithm</a>)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Explicit_Register_Renaming"><div class="tree-item-contents heading-link" heading-name="Explicit Register Renaming"><span class="tree-item-title">Explicit Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Explicit_Register_Renaming:_Detailed_Mechanism"><div class="tree-item-contents heading-link" heading-name="Explicit Register Renaming: Detailed Mechanism"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Explicit Register Renaming: Detailed Mechanism</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Hardware_Components"><div class="tree-item-contents heading-link" heading-name="Hardware Components"><span class="tree-item-title">Hardware Components</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#The_Pipeline_Process_with_Register_Renaming"><div class="tree-item-contents heading-link" heading-name="The Pipeline Process with Register Renaming"><span class="tree-item-title">The Pipeline Process with Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Register_Deallocation:_Managing_the_Physical_Register_Pool"><div class="tree-item-contents heading-link" heading-name="Register Deallocation: Managing the Physical Register Pool"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Register Deallocation: Managing the Physical Register Pool</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#When_can_a_physical_register_be_freed?"><div class="tree-item-contents heading-link" heading-name="When can a physical register be freed?"><span class="tree-item-title">When can a physical register be freed?</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Implementation_Approaches"><div class="tree-item-contents heading-link" heading-name="Implementation Approaches"><span class="tree-item-title">Implementation Approaches</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Integration_with_ROB"><div class="tree-item-contents heading-link" heading-name="Integration with ROB"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Integration with ROB</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Register_Renaming_and_Precise_Exceptions"><div class="tree-item-contents heading-link" heading-name="Register Renaming and Precise Exceptions"><span class="tree-item-title">Register Renaming and Precise Exceptions</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Register_Renaming_and_Branch_Prediction_(erroneous_speculation)"><div class="tree-item-contents heading-link" heading-name="Register Renaming and Branch Prediction (erroneous speculation)"><span class="tree-item-title">Register Renaming and Branch Prediction (erroneous speculation)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Benefits_of_Explicit_Register_Renaming"><div class="tree-item-contents heading-link" heading-name="Benefits of Explicit Register Renaming"><span class="tree-item-title">Benefits of Explicit Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Challenges_and_Considerations"><div class="tree-item-contents heading-link" heading-name="Challenges and Considerations"><span class="tree-item-title">Challenges and Considerations</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Multiple_Issue_and_Register_Renaming"><div class="tree-item-contents heading-link" heading-name="Multiple Issue and Register Renaming"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Multiple Issue and Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#The_Challenge_of_Multiple_Issue"><div class="tree-item-contents heading-link" heading-name="The Challenge of Multiple Issue"><span class="tree-item-title">The Challenge of Multiple Issue</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Basic_Strategy_for_Multiple_Issue_with_Register_Renaming"><div class="tree-item-contents heading-link" heading-name="Basic Strategy for Multiple Issue with Register Renaming"><span class="tree-item-title">Basic Strategy for Multiple Issue with Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Superscalar_Register_Renaming_Implementation"><div class="tree-item-contents heading-link" heading-name="Superscalar Register Renaming Implementation"><span class="tree-item-title">Superscalar Register Renaming Implementation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Multiple_Commit"><div class="tree-item-contents heading-link" heading-name="Multiple Commit"><span class="tree-item-title">Multiple Commit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Energy_Considerations"><div class="tree-item-contents heading-link" heading-name="Energy Considerations"><span class="tree-item-title">Energy Considerations</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Comparison:_Implicit_vs._Explicit_Register_Renaming"><div class="tree-item-contents heading-link" heading-name="Comparison: Implicit vs. Explicit Register Renaming"><span class="tree-item-title">Comparison: Implicit vs. Explicit Register Renaming</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="universitÃ /aca/notes/explicit-register-renaming.html#Summary_and_Key_Takeaways"><div class="tree-item-contents heading-link" heading-name="Summary and Key Takeaways"><span class="tree-item-title">Summary and Key Takeaways</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>